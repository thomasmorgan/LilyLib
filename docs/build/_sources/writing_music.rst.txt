Writing music
=========================

So far we have seen how music in LilyLib is composed of Points, and how we can use the `notes`, `rests` and `chords` functions to make multiple `Points`. In this section we'll look at functions that let us quickly writes higher-level musical entities, things like scales and arpeggios, as well as perform operations like transposition and harmonization. All these functions can be found within `points.py`.

Scales
-----------

The scale functions is as follows:

::

	def scale(start, stop_or_length, key, dur=None, step=1):
	    key = keyify(key)
	    return series(key.tones, start, stop_or_length, dur, step)

The arguments are:

- start; the tone at which to start the scale (can be a note too, the tone will be automatically extracted).
- stop_or_length; either the tone at which to stop, or a integer length (negative lengths create descending scales).
- key; the key in which to write the scale (see below for details)
- dur; the duration of any notes, can be a single value or a list of values which will be cycled. If no values is provided the function returns tones, and not Points.
- step; the step size. 1 = a full scale, 2 = every other note, 3 = every third note, and so on.

The demo_c_major_scale provides an example:

::

	from piece import Piece
	from points import scale


	class CMajorScale(Piece):

	    def details(self):
	        self.title = "C Major Scale"

	    def write_score(self):
	        self.score["treble"] = scale("c`", "c``", 'C Major', 8) + scale("c``", -8, 'C Major', 8)
	        self.score["bass"] = self.scale("c`", "c", 8) + self.scale("c", 8, 8)


	if __name__ == "__main__":
	    CMajorScale()

.. image:: _static/scales.png

First look at the treble clef. Note how the first scale specifies a stop tone, but the second specifies a numeric length. Both specify the key as C Major, and the duration as 8 (i.e. quavers). The bass is different though, it doesn't specify a key and it calls `self.scale` instead of `scale`. This is because the `Piece` class offers wrappers to all these functions, with the only difference being that it automatically passes the key of the piece. In this way you can use `self.scale` to compose in the dominant key of the piece, but `scale` when you want to create scales in another key. The demo `c_major_modal_scales` shows this in action, we'll deal with it in two parts. The first is:

::

	from piece import Piece
	from tones import letter
	from points import scale
	from util import join


	class CMajorModalScales(Piece):

	    def details(self):
	        self.title = "C Major Modal Scales"

	    def write_score(self):
	        # The looped section programmatically builds a series of scales
	        # Note that the bass clef is just a tansposition of the treble clef
	        looped = {"treble": []}
	        for start in self.scale('c`', 'c``'):
	            looped["treble"] += self.scale(start, 8, 8)
	        looped["bass"] = self.transpose(looped["treble"], -1, 'octave')

.. image:: _static/modal_scales1.png

Note how first a scale of tones is generated, and then these tones are used as the start notes of a series of scales, all in the dominant key of C Major. The bass clef is just a transposition of the treble clef, but more on transposition below.

::

	        # The smart section programmatically builds a series of scales in different keys
	        # Note how we use list comprehension to avoid a for loop, and use step = 2 to play every other note in the treble clef
	        start_notes = self.scale('c```', 'c``')
	        smart = {
	            "treble": [scale(start, -8, key=letter(start) + " major", dur=8, step=2) for start in start_notes],
	            "bass": [scale(self.transpose(start, -1, 'octave'), -8, key=letter(start) + " major", dur=8) for start in start_notes]
	        }

	        self.score = join(looped, smart)


	if __name__ == "__main__":
	    CMajorModalScales()


.. image:: _static/modal_scales2.png

The second part does the same thing, but note it takes the letter of the start tone and combines it with the word major to set the key. Thus the key of the scale changes with the start note. Keys are actually a class of object in Lilylib (see later docs), but they can be referred to with strings of the format "<base letter> <mode>", for instance: "c major", "fs minor", "bf harmonic". The lookup function is case insensitive, so capitalization does not matter.

In addition, note in the above demo that the treble clef sets the 'step' argument to 2, so the treble clef covers two octaves and catches up with the bass clef. Lastly, note that the score is the combination of the two dictionaries called `looped` and `smart` and they are combined with the function `join` which is imported from `util.py`.

Arpeggios
-----------

In addition to `scale`, `points.py` includes the function `arpeggio`, and `Piece` has a corresponding function which can be called with `self.arpeggio` too. Here's the function:

::

	def arpeggio(start, stop_or_length, key, dur=None, step=1):
	    key = keyify(key)
	    return series(key.arpeggio_tones, start, stop_or_length, dur, step)


Note it takes all the same arguments as the scale function. Just remember that the start tone must be part of the arpeggio in the key you are working with, so trying to start a C Major arpeggio on F won't get you very far. This function can be seen in action in the demo_arpeggios code:

::

	from piece import Piece
	from points import note, notes, arpeggio
	from util import join


	class Arpeggios(Piece):

	    def details(self):
	        self.title = "Arpeggios"

	    def write_score(self):
	        # The basic section manually builds a scale note by note
	        basic = {
	            "treble": [note("c`", 8), note("e`", 8), note("g`", 8), note("c``", 8)],
	            "bass": [note("c", 8), note("e", 8), note("g", 8), note("c`", 8)]
	        }

	        # The notes section uses the notes function to build a list of notes from a single string
	        intermediate = {
	            "treble": notes('d` fs` a` d``', 8),
	            "bass": notes('d fs a d`', 8)
	        }

	        # The arpeggio section uses the arpeggio function to build a scale from one note to the next
	        arpeggios = {
	            "treble": arpeggio('e`', 'e``', 'E Major', 8),
	            "bass": arpeggio('e', 4, 'E major', 8)
	        }

	        # The length section uses the arpeggio function to build an arpeggio, but specifies a length, rather than a stop note
	        length = {
	            "treble": arpeggio('f`', 4, 'F Major', 8),
	            "bass": arpeggio('f', 4, 'F Major', 8)
	        }

	        starts = self.arpeggio('c`', 'c``')
	        stepped = {
	            'treble': [[self.arpeggio(start, self.transpose(start, 7), 16, step=step) for step in [3, 3, 1]] for start in starts],
	            'bass': [[self.arpeggio(self.transpose(start, -7), start, 16, step=step) for step in [1, 3, 3]] for start in starts]
	        }

	        self.score = join(basic, intermediate, arpeggios, length, stepped)


	if __name__ == "__main__":
	    Arpeggios()


.. image:: _static/arpeggios.png

This shows a variety of ways you can make arpeggios. First using the `note` and `notes` functions, but then with `arpeggio` function itself. The `stepped` section uses a list of values for the step argument (along with pythonic list comprehension) to create something reminiscent of Beethoven's 3rd piano sonata.

Other series
---------------

Lilylib also includes functions that generate other common series of tones:

- arpeggio7; arpeggios including the 7th
- dominant7; dominant 7ths
- diminished7; diminished 7ths
- chromatic; chromatic scales

Though note that the dominant 7th function uses the 6th instead of the double-flattened 7th, as this typically produces cleaner notation. It's also worth remembering the dominant and diminished 7ths are the same for major, minor and harmonic versions of the same key. The chromatic function also follows convention by using sharps when the scale is ascending, and flats when descending, as this minimizes the number of accidentals. Here's the chromatic demo:

::

	from piece import Piece


	class ChromaticScales(Piece):

	    def details(self):
	        self.title = "Chromatic Scales in C and F Major"

	    def write_score(self):
	        self.score["treble"] = self.chromatic('c`', 'c``', [16] * 12 + [4]) + self.chromatic('c``', 'c`', [16] * 12 + [4])

	        self.set_key("f major")
	        self.score["treble"] += self.key_signature + self.chromatic('f`', 'f``', [16] * 12 + [4]) + self.chromatic('f``', 'f`', [16] * 12 + [4])

	        self.score["bass"] = self.transpose(self.score["treble"], -1, 'octave')


	if __name__ == "__main__":
	    ChromaticScales()

.. image:: _static/chromatic.png

You can also create custom scales with `scale_subset`:

::

	def scale_subset(positions, start, stop_or_length, key, dur=None, step=1):
	    key = keyify(key)
	    custom_tones = key.scale_subset(positions)
	    return series(custom_tones, start, stop_or_length, dur, step)

Here, `positions` is a list of numbers describing the points of the regular scale you want to include. So setting `positions` to [1, 3, 5] would produce regular arpeggios. Similarly, if you were Johannes Brahms and you regularly want a rolling left hand that includes root tones and 3rds you would use a scale subset with positions [1, 3].

Tranposition
----------------

We've seen `transpose` used a few times above. As the name suggests, it takes an (arbitrarily nested) list of Points, tones or strings, transposes it some a specified interval, and then returns the result. It's a long function so we won't show it all here, but here are the arguments:

::

	def transpose(item, shift, key, mode="scale"):

- item; the thing you want to transpose
- shift; the interval you want it transposed by
- key; the key in which the transposition occurs (see mode)
- mode; the "`kind`" of transposition. Either 'scale', 'octave' or 'semitone'.

You need to specify a key because otherwise transposing according to a scale is not possible. Most of the cases we've seen above are where the bass clef is a -1 octave (or -7 scale) transposition of the treble clef.

Here's the bit of the function that does the transposing (by this point it is working only with tones):

::

    try:
        if mode == "octave":
            new_pitch = all_pitches[all_pitches.index(pitch(item)) + shift]
            return letter(item) + new_pitch
        elif mode == "scale":
            current_index = key.tones.index(item)
            return key.tones[current_index + shift]
        elif mode == "semitone":
            return key.all_tones[key.all_tones.index(item) + shift]
    except ValueError:
        return transpose(equivalent_tone(item), shift, key, mode)

Note how if transposition fails, it tries again with the equivalent tone. This means if you try to transpose g-flat two steps up the scale of D Major, it will initially fail (g-flat is not in D Major) but will then transform g-flat to f-sharp, which can then be transposed to a.

Harmonization
-----------------

Lots of music involves relatively simple structures, like scales, but with harmonies imposed on the top. Lilylib can do this with the function `harmonize`. This function builds off `transpose`, but also another function `merge`. The `merge` function takes two or more series of points, and smushes them together to make a single series. This has a few limitations: to work the multiple passages must have the same number of points in them, and if their durations differ then the durations of the first passage overwrite the others. Lastly, if the multiple series have a nested structure then the return list will have the same structure as the first series the function is passed. Here's an example:

::

	from piece import Piece
	from points import rests, merge


	class Merge(Piece):

	    def details(self):
	        self.title = "Merged Scales"

	    def write_score(self):
	        scale_1 = self.scale("c`", 8, 8)
	        scale_2 = self.scale("c``", -8, 8)

	        self.score["treble"] = scale_1 + scale_2 + merge(scale_1, scale_2)
	        self.score["bass"] = rests(1, 1, 1)


	if __name__ == "__main__":
	    Merge()

.. image:: _static/merge.png

With this out of the way, harmonize works by first transposing points to the desired intervals and then merging the result with the original points:

::

	def harmonize(points, intervals, key, mode="scale"):
	    return merge(points, transpose(points, intervals, key, mode))

Here's a demo:

::

	from piece import Piece


	class Harmonize(Piece):

	    def details(self):
	        self.title = "Harmonized notes"

	    def write_score(self):

	        rh_melody = self.arpeggio('c`', 4, 4)
	        lh_melody = self.transpose(rh_melody, -1, 'octave')

	        self.score = {
	            'treble': self.harmonize(rh_melody, 3),
	            'bass': self.harmonize(lh_melody, -1, 'octave')
	        }


	if __name__ == "__main__":
	    Harmonize()

.. image:: _static/harmonize.png

